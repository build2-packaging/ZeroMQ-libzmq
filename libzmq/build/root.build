cxx.std = latest

using cxx
using c

hxx{*}: extension = hpp
cxx{*}: extension = cpp

h{*}: extension = h
c{*}: extension = c

# Assume headers are importable unless stated otherwise.
hxx{*}: cxx.importable = true

# The test target for cross-testing (running tests under Wine, etc).
test.target = $cxx.target

config [bool] config.libzmq.enable_intrinsics ?= false
config [bool] config.libzmq.enable_ws ?= true
config [bool] config.libzmq.enable_radix_tree ?= false
config [bool] config.libzmq.enable_gnutls ?= false
config [bool] config.libzmq.enable_ipc ?= true
config [bool] config.libzmq.enable_tipc ?= false
config [bool] config.libzmq.enable_militant_assert ?= false

# mode for polling, can be:
# kqueue, epoll, devpoll, pollset, poll, select or none
# in none mode a poll mode is chosen based on the target platform, but no real detection happens
config [string] config.libzmq.poll_mode ?= none

# mode for calling pthread_setname variants, values can be:
# setname_1, setname_2, setname_3, set_name or none
# in none mode a setname mode is chosen based on the target platform, but no real detection happens
config [string] config.libzmq.pthread_setname_mode ?= none

# forces to use mutexes instead of atomic variables (in case no atomics are available)
config [bool] config.libzmq.force_mutexes ?= false

# typically unix specific definitions
config [bool] config.libzmq.use_fork ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_clock_gettime ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_gethrtime ?= false
config [bool] config.libzmq.use_mkdtemp ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_uio ?= ($cxx.target.class != 'windows')

config [bool] config.libzmq.use_eventfd ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_eventfd_cloexec ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_ifaddrs ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_so_bindtodevice ?= ($cxx.target.class != 'windows')

config [bool] config.libzmq.use_so_peercred ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_local_peercred ?= false
config [bool] config.libzmq.use_o_cloexec ?= ($cxx.target.class != 'windows')

config [bool] config.libzmq.use_sock_cloexec ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_so_keepalive ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_so_priority ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_tcp_keepcnt ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_tcp_keepidle ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_tcp_keepintvl ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_tcp_keepalive ?= ($cxx.target.class != 'windows')

config [bool] config.libzmq.use_pthread_set_affinity ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_accept4 ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_strnlen ?= ($cxx.target.class != 'windows')
config [bool] config.libzmq.use_strlcpy ?= false

config [bool] config.libzmq.use_windows_uwp ?= false

config [uint64] config.libzmq.cacheline_size ?= 64


# if poll mode is not explicitly set, then determine the mode based on the target platform
poll_mode = $config.libzmq.poll_mode
if ($poll_mode == none)
{
    switch $cxx.target.class
    {
        case 'windows'
        {
            poll_mode = 'epoll'
        }
        case 'macos'
        {
            poll_mode = 'kqueue'
        }
        case 'linux'
        {
            poll_mode = 'select'
        }
        default
        {
            poll_mode = 'select'
        }
    }
}

# if pthread_setname is not explicitly set, then determine it based on the target platform
pthread_setname_mode = $config.libzmq.pthread_setname_mode
if ($pthread_setname_mode == none)
{
    switch $cxx.target.class
    {
        case 'macos'
        {
            pthread_setname_mode = 'setname_1'
        }
        case 'linux'
        {
            pthread_setname_mode = 'setname_2'
        }
        default
        {
            pthread_setname_mode = 'setname_1'
        }
    }
}
